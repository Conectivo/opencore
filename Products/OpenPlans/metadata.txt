=======================
 metadata manipulation
=======================

The basic usecase here is that objects need to notify and update
catalog metadata related to their container in order to facilitate
displaying the last object modified's time and modifier.

Let's get set up::

    >>> from Products.CMFCore.utils import getToolByName
    >>> from Products.Five.utilities import marker
    >>> from Products.OpenPlans import metadata as md
    >>> from Products.OpenPlans.Extensions.Install import installColumns
    >>> from Products.OpenPlans.interfaces.catalog import IIndexingGhost
    >>> from Products.OpenPlans.interfaces.project import IProject
    >>> from Products.ZCatalog import CatalogBrains
    >>> from StringIO import StringIO
    >>> from sets import Set
    >>> CatalogBrains.GETOBJECT_RAISES=False
    >>> fid = self.folder.invokeFactory('Document', id='test', title='TEST')
    >>> marker.mark(self.folder, IProject)
    >>> catalog = getToolByName(self.portal, 'portal_catalog')
    >>> catalog.indexObject(self.folder)

Check basic adaptation::

    >>> type(IIndexingGhost(self.folder)) == type(md.MetadataGhost(self.folder))
    True

now we can do some testing...

First, let's take a look at the metadata manipulation. First, let's
setup the extra columns::

    >>> out = StringIO()
    >>> installColumns(self.portal, out)
    >>> print out.getvalue().strip()
    metadata columns ('lastModifiedTitle', 'lastModifiedAuthor', 'lastModifiedComment') installed
    
    >>> Set(md.cols) & Set(catalog.schema()) == Set(md.cols)
    True

Now let's test the selective updating of metadata. This should only
change metadata that is specified by the proxy::

    >>> uid = '/'.join(self.folder.getPhysicalPath())

An empty proxy should do nothing::

    >>> md.selectiveMetadataUpdate(catalog._catalog, uid, md.proxy(dict()))
    >>> brain = catalog(path={'query' : '/'.join(self.folder.getPhysicalPath()), 'depth' : 0})[0]
    >>> brain.getId == self.folder.getId()
    True

    >>> brain.Title == self.folder.Title()
    True

Now, lets set the title::

    >>> title = 'New Title'
    >>> proxy = md.proxy(dict(Title=title))
    >>> md.selectiveMetadataUpdate(catalog._catalog, uid, proxy)
    >>> brain = catalog(path={'query' : '/'.join(self.folder.getPhysicalPath()), 'depth' : 0})[0]
    >>> brain.getId == self.folder.getId()
    True

    >>> brain.Title != self.folder.Title()
    True

    >>> brain.Title == title
    True

Now lets load up the ghosting adapter (see
interfaces.metadata.IIndexingGhost).

this will get tested more in an integration test with plone, but here
we will check the basics. Essentially, it's an alias to the existing
metadata record::

    >>> klass_dict = dict(zip(md.cols, range(3)))
    >>> proxy = md.proxy(klass_dict)
    >>> md.selectiveMetadataUpdate(catalog._catalog, uid, proxy)
    >>> mdg = IIndexingGhost(self.folder)

For metadata that does not exist as attr's or methods on the object,
the adapter should return whatever the current value of the metadata
column is for that uid::

    >>> mdg.getValue(md.cols[0])
    0
    >>> mdg.getValue(md.cols[1])
    1
    >>> mdg.getValue(md.cols[2])
    2

Finally, lets test the events that will be updating the
metadata. First we'll create a stub for portal_repository::

    >>> from Products.testing.editions import PortalRepository
    >>> self.portal.portal_repository = PortalRepository()
    >>> getToolByName(self.portal, 'portal_repository') is self.portal.portal_repository
    True

First, we'll hand feed the subscriber::

    >>> from Products.OpenPlans.interfaces import IProject
    >>> from Products.Five.utilities.marker import mark
    >>> mark(self.folder, IProject)
    >>> doc = getattr(self.folder, fid)
    >>> event = md.objectevent.ObjectModifiedEvent(doc)
    >>> md.updateContainerMetadata(doc, event)
    >>> brain = catalog(path={'query' : '/'.join(self.folder.getPhysicalPath()), 'depth' : 0})[0]
    >>> brain.lastModifiedTitle == doc.Title()
    True

    >>> brain.ModificationDate >= doc.modified()
    True

Now lets update the version info and hand feed the notification::

    >>> history = self.portal.portal_repository.history[0]
    >>> history.comment = 'New stuff'
    >>> history.sys_metadata['principal'] = 'U2'
    >>> md.notifyObjectModified(doc)
    >>> brain = catalog(path={'query' : '/'.join(self.folder.getPhysicalPath()), 'depth' : 0})[0]
    >>> brain.lastModifiedTitle == doc.Title()
    True

    >>> brain.ModificationDate >= doc.modified()
    True

Finally, lets decorate the edit method for document and fire an
event::

    >>> from Products.CMFDefault.Document import Document
    >>> Document.edit_old = Document.edit
    >>> Document.edit = md.addDispatcherToMethod(Document.edit, md.notifyObjectModified)
    >>> doc.edit('text/html', 'hellllllllo')
    >>> history.comment = 'more new stuff'
    >>> history.sys_metadata['principal'] = 'U3'
    >>> brain = catalog(path={'query' : '/'.join(self.folder.getPhysicalPath()), 'depth' : 0})[0]
    >>> brain.ModificationDate >= doc.modified()
    True
    >>> brain.lastModifiedAuthor
    'test_user_1_'

Return things to normal

    >>> CatalogBrains.GETOBJECT_RAISES=False

Let's make sure that we can get the id of the currently
authenticated member

    >>> md.getAuthenticatedMemberId(self.portal)
    'test_user_1_'
