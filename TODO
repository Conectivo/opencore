 * Take a look at featurelets; they are really doing the same thing as opencore.editform viewlets now, but with (I think) a less explicit API.  Could potentially clean them up to conform to the same IEditable interface and merge with EditFormViewlet.
--
So my first thought is that "FeatureletSupporter" is not a very useful concept.  I think it misses an opportunity for straightforward adaptation -- perhaps you register subscription adapters for featurelets, and iterate over the subscribed featurelets.

But actually, why not just directly adapt "featurelet supporters" to "featurelet types"?  I think that is more direct:

opencore.listen.featurelet

>>> project = IProject(name='aproject')
>>> project
<OpenProject aproject at /openplans/projects/aproject/ >
>>> IListenContainer(project)
<ATFolder lists at /openplans/projects/aproject/lists/ >
>>> page = IWikiPage(name='apage', parent=project)
>>> page
<OpenPage apage at /openplans/projects/aproject/wiki/apage/ >
>>> IListenContainer(page)
<OpenPage apage at /openplans/projects/aproject/wiki/apage/ >
>>> IListenContainer(page).lists
[<OpenList apage-discussion at /openplans/project/aproject/wiki/apage/apage-discussion/ >]
>>> IListenFeaturelet(project)
<ListenFeatureletSupporter adapting /openplans/projects/aproject/ >
>>> IListenFeaturelet(project).uninstall()
>>> IListenContainer(project)
Traceback (most recent call last):
...
ComponentLookupError...

So I think we only need one particular concept: a "Featurelet" is something that installs an associated marker interface on a content object which enables particular configured behavior ie IObjectCreated subscribers and adapters. Let's start out with an informal convention for this Featurelet type.
--

That might in turn help unify the code between content-add and content-edit.  Which would go a long way towards reducing code in general.

At that point, things might be clean enough to try creating an explicit "edit form view" type which does the validate()->return(errors)->save()->redirect(url) chain automatically on form submission.

Open question: should plugins provide abstraction layer for validate() and save() that sits between content and viewlet class? I don't think so; just rename EditFormViewlet to EditFormPlugin or something, since the viewlet is actually the dynamically typed object created by configuration; the viewlet's class _is_ that abstraction layer, just make that more explicit. (So the template isn't actually necessary for interacting with it.)

One day: clean up things like view code for file attachments, image upload, etc.. put them in base IEditable(contenttype) or plugin-type code

 * Perhaps plugins should actually register as subscription adapters? [IEditable(adapted) for adapted in IExtensions(content)]

 * Content types for extensible content, implementations as plone/AT type factories

def __call__():
    if POST:
       self.validate()
       self.save()
       self.redirect()