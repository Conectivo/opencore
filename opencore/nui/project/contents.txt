=======================
 Project Contents View
=======================

    >>> self.loginAsPortalOwner()
    >>> proj = self.portal.projects.p2
    >>> view = proj.restrictedTraverse('contents')
    >>> view
    <...SimpleViewClass ...contents.pt ...>

The view has properties to get info for all of the project's
wiki pages, file attachments and mailing lists::

    >>> view.pages
    [{...}]
    >>> len(view.pages)
    2
    >>> len(view.lists)
    1
    >>> len(view.files)
    2

The view has properties to determine whether the project has relevant
featurelets installed::

    >>> view.has_task_tracker
    False
    >>> view.has_mailing_lists
    False

Object abstraction
==================

_make_dict_and_translate is a non-public method for abstracting
objects: given an object and an attribute translation dictionary,
it will return a dictionary of attributes and values for that object.
This allows templates to ignore object details like the precise spelling
of their attributes. Translation dictionaries are defined for Documents,
FileAttachments, Images, and Mailing Lists in ProjectContentsView.needed_values

    >>> pages = view.catalog(portal_type="Document",
    ...                      path='/'.join(view.context.getPhysicalPath()))
    >>> trans = view.needed_values['pages']
    >>> d1 = view._make_dict_and_translate(pages[0], trans)
    >>> d2 = view._make_dict_and_translate(pages[0].getObject(), trans)
    >>> d1 == d2
    True

    >>> pages = view.catalog(portal_type="Open Mailing List",
    ...                      path='/'.join(view.context.getPhysicalPath()))
    >>> trans = view.needed_values['lists']
    >>> d1 = view._make_dict_and_translate(pages[0], trans)
    >>> d2 = view._make_dict_and_translate(pages[0].getObject(), trans)
    >>> d1 == d2
    True

    >>> pages = view.catalog(portal_type=("FileAttachment","Image"),
    ...                      path='/'.join(view.context.getPhysicalPath()))
    >>> trans = view.needed_values['files']
    >>> d1 = view._make_dict_and_translate(pages[0], trans)
    >>> d2 = view._make_dict_and_translate(pages[0].getObject(), trans)
    >>> d1 == d2
    True



Multipart-Form handler
======================

modify_contents is the view's form handler. It takes an action, a list
of sources, and a list of dicts of fields and values to apply to the
sources. These are all filled and passed in from the request via the
octopus_form_handler decorator provided the request uses a particular
format documented in octopus_form_handler. For asynchronous requests,
the return value from modify_contents (HTML or JSON) is sent; for
synchronous requests, a redirect back to the referer is issued.

Let's set up a request to synchronously rename the first wiki page in
the project's contents listing to "Hobbes"::

    >>> page = proj.new1
    >>> page.Title()
    'new title'

    >>> request = self.portal.REQUEST
    >>> form = {'task': 'new1_update',
    ...         'new1_title': 'Hobbes',
    ...         'item_type': 'pages'}
    >>> request.form = form
    >>> request.environ['HTTP_REFERER'] = 'http://nohost/openplans/projects/p2/contents'
    >>> view.modify_contents()
    'http://nohost/openplans/projects/p2/contents'

    >>> page.Title()
    'Hobbes'

We can also issue the request asynchronously::

    >>> request = self.portal.REQUEST
    >>> form = {'task': 'new1_update',
    ...         'new1_title': 'Hume',
    ...         'item_type': 'pages',
    ...         'mode': 'async'}
    >>> request.form = form
    >>> view.modify_contents()
    {'new1': '...<tr ...>...'}

    >>> page.Title()
    'Hume'

Deletes work the same way::

    >>> view = proj.restrictedTraverse('contents')
    >>> request = self.portal.REQUEST
    >>> form = {'task': 'new1_delete',
    ...         'item_type': 'pages',
    ...         'mode': 'async'}
    >>> request.form = form
    >>> view.modify_contents()
    ['new1']

    >>> proj.restrictedTraverse('new1')
    Traceback (most recent call last):
    ...
    AttributeError: new1
    >>> x = view.pages
    >>> x[1]
    Traceback (most recent call last):
    ...
    IndexError: list index out of range
    >>> len(x)
    1

To perform a batch action, label the task as batch and provide a
batch[] field with item ids. Provide all the fields necessary for
performing the action on all the items in the batch; extra fields
will be ignored and only the items listed in the batch will be
acted upon::
    >>> proj.img1.Title()
    'new image'
    >>> proj.restrictedTraverse('project-home').fa1.Title()
    'new file'
    >>> proj.lists.list1.Title()
    'new list'

    >>> request = self.portal.REQUEST
    >>> form = {'task': 'batch_update',
    ...         'item_type': 'files',
    ...         'fa1_title': 'Castor',
    ...         'img1_title': 'Polydeuces',
    ...         'list1_title': 'Clytemnestra',
    ...         'mode': 'async',
    ...         'batch[]':['fa1', 'img1']}
    >>> request.form = form
    >>> sorted(view.modify_contents().keys())
    ['fa1', 'img1']

    >>> proj.img1.Title()
    'Polydeuces'
    >>> proj.restrictedTraverse('project-home').fa1.Title()
    'Castor'
    >>> proj.lists.list1.Title()
    'new list'


Batch deletes work the same way::
    >>> view = proj.restrictedTraverse('contents')
    >>> proj.restrictedTraverse('img1')
    <ATImage at ...>

    >>> request = self.portal.REQUEST
    >>> form = {'task': 'batch_delete',
    ...         'item_type': 'files',
    ...         'mode': 'async',
    ...         'batch[]':['fa1', 'img1']}
    >>> request.form = form
    >>> view.modify_contents()
    ['fa1', 'img1']

    >>> proj.restrictedTraverse('img1')
    Traceback (most recent call last):
    ...
    AttributeError: img1

    >>> len(view.files)
    0

Let's delete the mailing list too, to clean up::
    >>> view = proj.restrictedTraverse('contents')
    >>> request = self.portal.REQUEST
    >>> form = {'task': 'list1_delete',
    ...         'item_type': 'lists',
    ...         'mode': 'async'}
    >>> request.form = form
    >>> view.modify_contents()
    ['list1']
    >>> len(view.lists)
    0
