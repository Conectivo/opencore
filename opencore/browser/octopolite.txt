OctopoLite.
It is a fusion of Octopus and FormLite.

FormLite provides a simple base class and @action decorator to handle
method dispatch based on request keys; see formlite.txt for details.

Octopus provides handling of some form conventions that allow views to
provide form handling both synchronously (returning complete HTML to
the browser) and asynchronously (returning JSON for AJAX usage).

OctopoLite combines them. To use OctopoLite in a view::

 * bind a single view in ZCML with no attribute or template

 * extend BaseView and OctopoLite, eg


      class MyView(BaseView, OctopoLite):

 * specify a default dispatchable method for rendering the form, eg

          @action('render_form', default=True)
          def render_form(self, target=None, fields=None):
              return ZopeTwoPageTemplateFile('myform.pt')()

 * specify dispatchable methods for all of your form actions, eg

          @action('delete', apply=post_only)
          def handle_delete(self, target=None, fields=None):
              cmds = {}
              for oid in target:
                  del self.obj[oid]
                  cmds[oid] = {'action': 'delete'}
              return cmds

And that's about it! Note the required target, fields signature for
your action methods. See bottom of this file for the syntax of
the JSON object to be returned to the client.

   >>> from opencore.browser.formhandler import OctopoLite, action
   >>> def decorator(func):
   ...     def inner(self, *a, **b):
   ...         print "in decorator!"
   ...         return func(self, *a, **b)
   ...     return inner
   >>> 
   >>> class FormTest(OctopoLite):
   ...     
   ...     template = lambda self: 'my template'
   ...     request = type('request', (object,), dict(form={}, environ={'HTTP_REFERER': "http://nohost"}))
   ...     
   ...     @action('roklok', default=True)
   ...     def do_roklok(self, target=None, fields=None):
   ...         print "Rock!"
   ...         
   ...     @action('sod')
   ...     def do_sign_of_devil(self, target, fields=None):
   ...         print "eggs of the devil!"
   ...         return [i for i in target]
   ...     
   ...     @action('fine', apply=decorator)
   ...     def fine(self, target=None, fields=None):
   ...         print "fine!"
   ...         

   >>> view = FormTest()

The dispatcher is a rock. It dispatches based on the action it finds
in the form, encoded in an octopized format in the "task" field::

   >>> view.request.form['task|dummy|sod'] = 'Foo'
   >>> view()
   eggs of the devil!
   'my template'


Using OctopoLite with AJAX
===========================

Since the requests we've made were issued synchronously, Octopolite
swallowed the method's return value and returned a rendered
template. We can issue requests asynchronously to get back the return
value directly. To do that, add mode=async to the request::

   >>> view.request.form['mode'] = 'async'

Stub out response (will be set in BaseView when live)
   >>> class ResponseStub(object):
   ...     def setHeader(self, *a):
   ...         return None
   >>> view.response = ResponseStub()

   >>> view()
   eggs of the devil!
   '...dummy...'

A request with no actions will dispatch to the action specified as default::

   >>> view.request.form = {'mode': 'async'}
   >>> view()
   Rock!
   '...{}...'

You will probably want to specify decorators, like post_only or
jsonify, to be triggered only if the action is dispatched to, but
are not triggered if the action is called directly::

   >>> view.request.form['task|dummy|fine'] = 'Click here!'
   >>> view()
   in decorator!
   fine!
   '...{}...'

   >>> view.fine()
   fine!


Returning JSON from actions
============================

The JSON is for consumption by the opencore.js javascript library, so
it must conform to this format:

Return a dictionary whose KEYS are ids of existing DOM elements on the
page, and whose VALUES are a JSON object (with all fields optional):

class ActionInfo {
  string html;   # a string which can be evaluated as HTML and rendered 
                 # into DOM elements (quoted HTML or plain text)
  string effect; # a comma-separated string of JavaScript effects to apply
                 # to the element referred to in the id key, like fadeOut,
                 # highlight, or blink (we need to define a fixed set)
  string action; # a string indicating what action to take on the DOM element
                 # specified in the id key: replace, drop, append, prepend, copy
}

So a sample response might look like

{'msg_el': {'html': "Changes saved!", 'action': "copy", 'effect':"blink"},
 'obj_id': {'action': "delete"} }
