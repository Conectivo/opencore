"""
some base class for opencore ui work!
"""
from Acquisition import aq_inner, aq_chain
from Products.CMFCore.utils import getToolByName
from Products.CMFPlone.interfaces import IPloneSiteRoot
from Products.Five import BrowserView
from Products.Five.browser.pagetemplatefile import ZopeTwoPageTemplateFile
from Products.remember.interfaces import IReMember
from lxml.html.clean import Cleaner
from opencore.i18n import i18n_domain, _
from opencore.i18n import translate
from opencore.utility.interfaces import IProvideSiteConfig
from opencore.interfaces import IHomePage
from opencore.project.utils import project_noun
from plone.memoize import instance
from plone.memoize import view
from topp.utils import zutils
from topp.utils.pretty_date import prettyDate
from zope.component import getMultiAdapter, getUtility
from zope.i18nmessageid import Message
import DateTime
import cgi
import logging

try:
    from opencore.streetswiki.interfaces import IWikiContainer
except ImportError:
    IWikiContainer = None

view.memoizedproperty = lambda func: property(view.memoize(func))
view.mcproperty = lambda func: property(view.memoize_contextless(func))
logger = logging.getLogger("opencore.browser.base")

class BaseView(BrowserView):
    """Base view for general use for nui templates and as an abstract base"""

    # @@ DWM: following should go in configuration
    logoURL = '++resource++img/logo.gif'
    defaultPortraitURL = '++resource++img/default-portrait.gif'
    defaultPortraitThumbURL = '++resource++img/default-portrait-thumb.gif'
    defaultPortraitSquareThumbURL = '++resource++img/default-portrait-80x80.gif'
    defaultPortraitSquareFiftyThumbURL = '++resource++img/default-portrait-50x50.gif'
    defaultProjLogoURL = '++resource++img/default-projlogo.gif'
    defaultProjLogoThumbURL = '++resource++img/default-projlogo-thumb.gif'
    windowTitleSeparator = ' :: '
    site_iface = IPloneSiteRoot

    main_macros = ZopeTwoPageTemplateFile('main_macros.pt')

    def __init__(self, context, request):
        self.context      = context
        self.request      = request
        self.transcluded  = request.get_header('X-transcluded')
        self.errors = {}
        self.response = self.request.RESPONSE
    
    def get_config(self, option, default=''):
        # XXX As of 5/20/08 only Sputnik templates use this method,
        # but I don't feel like doing the work to move it elsewhere,
        # because sputnik often uses views that derive from this class
        # and not from anything sputnik-specific ... so there's no
        # existing class that's a good place to put it.
        return getUtility(IProvideSiteConfig).get(option, default=default)


    def project_url(self, project=None, page=None):
        """This should be the canonical way for views to get a url
        related to projects.  Returns an absolute URL.

        (This falls short of Ian's proposal to have a single function
        for ALL URIs generated by opencore, but we didn't want to get
        distracted thinking of a good API for that. We can revisit
        later.)
        """
        #XXX we need to currently use project for all urls
        # and *not* what's in the project noun, because we'll link
        # to things like /groups, which doesn't currently exist
        parts = [self.portal.projects.absolute_url()]
        if project is not None:
            parts.append(project)
        if page is not None:
            parts.append(page)
        return '/'.join(parts)

    @property
    def project_noun(self):
        """Do we call them 'projects' or 'groups' or... ?
        """
        return project_noun()

    def redirect(self, *args, **kwargs):
        self._redirected = True
        return self.request.response.redirect(*args, **kwargs)

    def spamProtect(self, mailaddress, mailname=None):
        """
        Returns a spam protected mail address tag.  Lifted from the
        Plone skin script of the same name.
        """
        email = mailaddress.replace('@', '&#0064;').replace(':', '&#0058;')
        if mailname is None:
            mailname = email
        return '<a href="&#0109;ailto&#0058;' + email + '">' + mailname + '</a>'

    def render_macro(self, macro, extra_context={}):
        """
        Returns a rendered page template which contains nothing but a
        provied macro.

        o macro: the macro list representation which should be
        rendered within the returned template object.
        """
        template = ZopeTwoPageTemplateFile('macro_snippet.pt').__of__(self)
        template._cook_check()
        extra_context['macro'] = macro
        return template.pt_render(extra_context=extra_context)

    def translate(self, msgid, domain=i18n_domain, mapping=None,
                  target_language=None, default=None):
        """
        Wrapper around translate machinery which defaults to our i18n
        domain and the current context object.  Returns instance of
        unicode type.
        """
        context = aq_inner(self.context)
        kw = dict(domain=domain, mapping=mapping, context=context,
                  target_language=target_language, default=default)
        return translate(msgid, **kw)

    @property
    def portal_status_message(self):
        # @@ consider moving to a function
        
        # Note, showPortalMessages returns AND CLEARS them.
        # Hence this oddity: we don't want to clear them
        # if this view is redirecting, because then nobody would
        # ever see them.
        if hasattr(self, '_redirected'):
            return []
        plone_utils = self.get_tool('plone_utils')
        msgs = plone_utils.showPortalMessages()
        if msgs:
            msgs = [msg.message for msg in msgs]
        else:
            msgs = []
        req_psm = self.request.form.get("portal_status_message")
        if req_psm:
            req_psm = cgi.escape(req_psm)
            msgs.append(req_psm)
        return msgs

    # XXX standardize
    def add_status_message(self, msg):
        plone_utils = self.get_tool('plone_utils')

        # portal messages don't seem to get translated implicitly
        # this is why there's an explicit translate here
        if isinstance(msg, Message):
            msg = self.translate(msg)
        else:
            msg = _(msg)

        cleaner = Cleaner()
        msg = cleaner.clean_html(msg)
        if msg.startswith('<p>'):
            msg = msg[3:-4]
        msg = unicode(msg)
        plone_utils.addPortalMessage(msg, request=self.request)

    addPortalStatusMessage = add_status_message

    @view.memoizedproperty
    def wiki_container(self):
        """
        Check aq_chain for IWikiContainer objects, return if exists.
        """
        if IWikiContainer is None: # streetswiki isn't installed
            return
        chain = aq_chain(aq_inner(self.context))
        for item in chain:
            if IWikiContainer.providedBy(item):
                return item

    @view.memoizedproperty
    def area(self):
        if self.miv.inMemberArea or self.miv.inMemberObject:
            return self.miv.member_folder or self.miv.member_object
        elif self.piv.inProject:
            return self.piv.project
        elif self.wiki_container is not None:
            return self.wiki_container
        else:
            return self.portal

    def window_title(self, mode='view'):
        """see http://trac.openplans.org/openplans/ticket/588.
        mode should be one of: 'view', 'edit', or 'history'."""
        if mode == 'view':
            mode = ''
        else:
            mode = '(%s) ' % mode

        context = self.context
        title = context.Title().decode("utf-8")

        if self.miv.inMemberArea or self.miv.inMemberObject:
            vmi = self.viewed_member_info
            if not mode and vmi['home_url'] == context.absolute_url():
                # viewing member homepage
                return '%s on %s' % (vmi['id'], self.portal.Title())
            else:
                return '%s %s- %s on %s' % (title, mode, vmi['id'],
                                            self.portal.Title())
        elif self.piv.inProject:
            project = self.piv.project
            if not mode and self.context.getId() == IHomePage(project).home_page:
                # viewing project home page
                return '%s - %s' % (project.Title().decode('utf-8'), self.portal.Title())
            elif self.context != project:
                return '%s %s- %s - %s' % (title, mode, project.Title().decode('utf-8'),
                                           self.portal.Title())
        elif self.wiki_container is not None \
                 and context != self.wiki_container:
            return '%s %s- %s - %s' % (title, mode, self.area.Title(),
                                       self.portal.Title())

        # safe catch-all for any case not specifically covered above
        if title == self.portal.Title():
            return '%s %s' % (title, mode)
        else:
            return '%s %s- %s' % (title, mode, self.portal.Title())

    # XXX cache more rigorously
    @view.memoize_contextless
    def nusers(self): 
        """Returns the number of users of the site."""
        users = self.membranetool(getId='')
        return len(users)

    # XXX cache more rigorously
    @view.memoize_contextless
    def projects_served_count(self): 
        """
        Returns the total number of projects hosted by the site,
        including those not visible to the current user.
        """
        projects = self.catalog.unrestrictedSearchResults(portal_type='OpenProject')
        return len(projects)

    @property
    def member_info(self):
        """
        Returns a dict containing information about the currently
        authenticated member for easy template access.  If the member
        is not currently logged in, the returned dictionary will be
        empty.
        """
        return self.member_info_for_member(self.loggedinmember)

    @instance.memoizedproperty
    def viewed_member_info(self):
        """
        Returns a dict containing information about the currently
        viewed member for easy template access.
        """
        return self.member_info_for_member(self.viewedmember())

    def mship_brains_for(self, member):
        teamtool = getToolByName(self.context, 'portal_teams')
        default_states = teamtool.getDefaultActiveStates()
        return self.catalog(id=member.getId(),
                            portal_type='OpenMembership',
                            review_state=default_states)

    def project_brains_for(self, member):
        if not IReMember.providedBy(member):
            return []
        mships = self.mship_brains_for(member)
        teams = [i.getPath().split('/')[-2] for i in mships]
        projects = self.catalog(portal_type='OpenProject', id=teams)
        return sorted(projects, key=lambda b:b.getId.lower())

    def project_brains(self):
        return self.project_brains_for(self.loggedinmember)

    def member_info_for_member(self, member):
        if member == None:
            # Not logged in.
            return {}
        id = member.getId()
        result = {'id': id}
        folder = self.membertool.getHomeFolder(id)
        if folder:
            result['url'] = folder.absolute_url()
        
        if IReMember.providedBy(member):
            logintime = member.getLogin_time()
            if logintime == DateTime.DateTime('2000/01/01'): # XXX hack around zope
                logintime = 'never'
            else:
                logintime = logintime and prettyDate(logintime) or 'member.getLogin_time() is None?'
            
            result.update(
                id          = id,
                fullname    = member.getFullname(),
                email       = member.getEmail(),
                membersince = prettyDate(member.creation_date),
                lastlogin   = logintime,
                folder_url  = self.memfolder_url(id_=id),
                home_url    = self.memhome_url(id_=id),
                projects    = self.project_brains_for(member),
                location    = member.getLocation(),
                statement   = member.getStatement(),
                background  = member.getBackground(),
                skills      = member.getSkills(),
                affiliations= member.getAffiliations(),
                website     = member.getWebsite(),
                favorites   = member.getFavorites(),
                anon_email  = member.getUseAnonByDefault(),
                )
        else:
            # XXX TODO 
            # we're an old school member object, e.g. an admin user
            result.update(fullname=member.fullname)

            for key in 'membersince', 'lastlogin','location', \
                    'statement', 'affiliations', 'skills', \
                    'background',  'url', 'favorites', 'folder_url':
                result[key] = ''

        folder = self.membertool.getHomeFolder(result['id'])
        if folder:
            result['url'] = folder.absolute_url()

        # @@ DWM: should be in an adapter or on the member object
        result['portrait_url'] = self.defaultPortraitURL
        portrait = member.getProperty('portrait', None)
        if portrait:
            result['portrait_url'] = portrait.absolute_url()
            result['portrait_thumb_url'] = "%s_thumb" %portrait.absolute_url()
            result['portrait_width'] = str(portrait.width)
        else:
            result['portrait_thumb_url'] = self.defaultPortraitThumbURL
            result['portrait_width'] = '200' # XXX don't hard code width of default portrait

        return result

    # tool and view handling

    # PW: I don't know what motivated caching tool lookups; I did some
    # quick timeit benchmarks and determined that this saves maybe
    # 0.00001 seconds per lookup, so I really doubt there will ever be
    # a bottleneck here.
    @view.memoize_contextless
    def get_tool(self, name):
        """
        Returns the specified tool.  Uses the context of the view as
        the context for the getToolByName call.
        """
        return getToolByName(self.context, name)

    @view.mcproperty
    def portal(self):
        return aq_iface(self.context, self.site_iface)

    def portal_title(self):
        return self.portal.Title()
    
    @view.memoize
    def get_view(self, name):
        # as of 2008/04/14, this is only used by this class and topnav
        view = getMultiAdapter((self.context, self.request), name=name)
        return view.__of__(aq_inner(self.context))

    #egj: piv? miv? these names suck.
    @property
    def piv(self):
        return self.get_view('project_info')

    @property
    def miv(self):
        return self.get_view('member_info')

    @property
    def dob(self):
        return prettyDate(self.portal.created())

    @property
    def came_from(self):
        # pw: as of 2008/04/14, not much uses this base class implementation,
        # but formhandler.anon_only requires all views to have it.
        came_from = self.request.get('came_from')
        return came_from or getToolByName(self.context, 'portal_url')()

    @property
    def name(self):
        """The name this view is registered for. We sometimes use this
        for constructing a link to the current view (for
        eg. self-posting forms"""
        return self.__name__

    # This is only here for documentation purposes; a lot of our form
    # handlers have a handle_request implementation.  Should it be
    # defined on some interface instead?
    def handle_request(self):
        raise NotImplementedError

    # properties and methods associated with members

    @property
    def loggedinmember(self):
        if self.loggedin:
            # XXX This can sometimes lead to downstream confusion by
            # returning users who aren't full site members,
            # eg. in tests where we've called loginAsPortalOwner()
            return self.membertool.getAuthenticatedMember()

    @view.memoize
    def memfolder(self, id_=None):
        if id_ is None:
            if not self.loggedin:
                return None
            id_ = self.member_info['id']
        return self.membertool.getHomeFolder(id_)

    def memfolder_url(self, id_=None):
        """url of the given member's homepage.
        if none is specified, use logged-in member"""
        folder = self.memfolder(id_)
        if folder is not None:
            return folder.absolute_url()

    def memhome_url(self, id_=None):
        if id_ is None:
            if not self.loggedin:
                return None
            id_ = self.member_info['id']
        folder = self.memfolder(id_)
        if folder is not None:
            return '%s/%s-home' % (folder.absolute_url(),
                                   id_)

    @property
    def loggedin(self):
        return not self.membertool.isAnonymousUser()

    @view.memoize
    def viewedmember(self):
        """Returns the user found in the context's acquisition chain, if any."""
        #egj: this feels very convoluted, do we need to do it this way?
        return self.miv.member


    # properties and methods associated with objects

    @property
    def membranetool(self):
        return self.get_tool('membrane_tool')
    
    @property
    def membertool(self):
        return self.get_tool('portal_membership')
    
    @property
    def catalog(self):
        return self.get_tool('portal_catalog')

    @instance.clearbefore
    def _clear_instance_memos(self):
        pass

    def pretty_date(self, date):
        return prettyDate(date)

    def get_tab_class(self, link):
        css_class = ''
        if not isinstance(link, list):
            link = [link]

        if self.name in link:
            css_class = 'oc-selected'

        if u'edit' in link:
            if not self.get_tool("portal_membership").checkPermission("Modify portal content", self.context):
                css_class = 'oc-notallowed'

        return css_class

    def render_base_tag(self):
        """return the html that main template uses to fix relative links

        turning it off in the base template conditionally fails
        because the tal doesn't get rendered"""
        base_url = self.context.absolute_url()
        return """\
                <!--[if IE 6]><![if !IE 6]><![endif]-->
        <base href="%s/" />
                <!--[if IE 6]><![endif]><![endif]-->""" % base_url


    def validate_password_form(self, password, password2, member):
        messages = []
        def exit_function():
            """bridge code to going forward. use this instead of return"""
            # XXX ultimately validate_password_form should play more nicely with messages
            if messages:
                for msg in messages:
                    self.addPortalStatusMessage(msg)
                return False
            return member

        if isinstance(member, basestring):
            # get the member object
            id = member
            if not id:
                messages.append(_(u'password_no_username_error', u'You need to enter your username.'))
                return exit_function()
                
            member = self.get_tool("membrane_tool")(getUserName=id)
            if not member:
                messages.append(_(u'password_no_member_error', u'There is no member named "${user_id}".',
                                  mapping={u'user_id':id}))
                return exit_function()
            member = member[0].getObject()

        if not password or not password2:
            messages.append(_(u'password_no_password_error', u"You must enter a password."))
            return exit_function()
        if password != password2:
            messages.append(_(u'password_not_same_error', u"Please make sure that both password fields are the same."))
            return exit_function()
        msg = member.validate_password(password)
        if msg:
            messages.append(msg)
            return exit_function()
        return exit_function() # XXX redundant, leaving for now


aq_iface = zutils.aq_iface
