Formlite. 
It's getting fatter.

FormLite provides a minimal framework for dispatching to methods based
on "action" keys found in the request.  The dispatching is invoked by
FormLite.handle_request().

This is basically like the action dispatching part of
zope.formlib.form. XXX What's different about it?


Basic Usage
===========


Typical FormLite usage is to create a subclass, and decorate its
methods with the @action decorator.

   >>> from opencore.browser.formhandler import FormLite, action
   >>> class FormTest(FormLite):
   ...     request = type('request', (object,), dict(form={}))()
   ...     
   ...     @action('roklok', default=True)
   ...     def do_roklok(self):
   ...         print "Rock!"
   ...         
   ...     @action('sod')    
   ...     def do_sign_of_devil(self):
   ...         print "eggs of the devil!"
   ...     
   >>> view = FormTest()

The dispatch methods are loaded into a dictlike object::

   >>> pprint(view.actions)
   {'roklok': <....Action object at ...>,
    'sod': <....Action object at ...>}

We marked the 'roklok' action as the default action::

   >>> view.actions.default is view.actions['roklok']
   True

The dispatcher is dumb as a rock.  Whatever action it finds first, it executes::

   >>> view.request.form = {'sod': True}
   >>> view.handle_request()
   eggs of the devil!
   

A request with no actions will pass without incident, unless you
set a default action::

   >>> view.request.form = {}
   >>> view.handle_request()
   Rock!



Using Decorated Methods as Actions
==================================

The __name__ of the method decorated with @action is used in a getattr
to find the method to call. If you use additional decorators, the
outermost decorator before @action must ensure that the __name__ of
the function it returns is identical to that of the underlying method.

If your decorator doesn't do that, you'll get an AttributeError::

   >>> def dumb_decorator(func):
   ...     def inner(self):
   ...         print "in dumb_decorator"
   ...         return func(self)
   ...     return inner

   >>> class FormTest2(FormTest):
   ...     
   ...     @action('yes1')
   ...     @dumb_decorator
   ...     def broken(self):
   ...         print "ok"

   >>> view = FormTest2()
   >>> view.request.form = {'yes1': True}
   >>> view.handle_request()
   Traceback (most recent call last):
   ...
   AttributeError: 'FormTest2' object has no attribute 'inner'


It works if your decorator properly sets __name__::

   >>> def better(func):
   ...     def myinner(self):
   ...         print "in better"
   ...         return func(self)
   ...     myinner.__name__ = func.__name__
   ...     return myinner

   >>> class FormTest3(FormTest):
   ...     
   ...     @action('yes2')
   ...     @better
   ...     def working(self):
   ...         print "working!"

   >>> view = FormTest3()
   >>> view.request.form = {'yes2': True}
   >>> view.handle_request()
   in better
   working!

Alternatively you can pass a decorator or a tuple of decorators to
@action in the `apply' argument. These decorators will be applied to
the method before it is called on dispatch, and the decorators do not
have to worry about setting __name__.

   >>> class FormTest4(FormTest):
   ...     
   ...     @action('yes3', apply=(dumb_decorator, dumb_decorator))
   ...     def notbroken(self):
   ...         print "fine!"
   ...         

   >>> view = FormTest4()
   >>> view.request.form = {'yes3': True}
   >>> view.handle_request()
   in dumb_decorator
   in dumb_decorator
   fine!

In that case, your methods will be decorated *if and only if* they are
called by action dispatch; when called directly the methods will not
be decorated::

   >>> view.notbroken()
   fine!

And all methods still work as normal::

   >>> view.do_roklok()
   Rock!
